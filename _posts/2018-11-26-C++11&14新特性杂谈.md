---
layout:  post
title:		C++11&14新特性杂谈
subtitle:	C++常见问题（四）
date:     2018-11-26
author:   Francis-wu
header-img: img/post-bg-2015.jpg
catalog: true
tags:
    - C++
---
>回顾复习一些常见的C++问题，以及一些没有仔细考虑过的地方。（任何问题欢迎邮件:[admin@fraciswu.top](admin@fraciswu.top)）
>
>2B公司还是VS2005搞破鞋，导致新特性都没咋用过，都是零散看了一些，最近刚好有个讲座，下面是学习笔记以及思考。

### 1、nullptr

​    比较老的版本里一般使用`#define NULL 0`来判断空指针，在一些情况下，比如函数参数是指针的，函数又有重载（int），函数匹配会有问题，造成一些不优雅的情况。新版本添加了定义`std::nullptr`来专门指代空指针来解决这个问题。

### 2、自动类型推导 auto/decltype

 auto定义：

- 对于变量，指定其类型将从其初始化器自动推导而出
- 对于函数，指定其返回类型是尾随的返回类型或将从其return 语句推导出 (C++14 起)
- 对于非类型模板形参，指定其类型将从参数推导出(C++17 起)

正常使用姿势：

```c++
std::vector<int>V;
/*老版本*/
for(std::vector<int>::iterator iter = V.begin();
   iter != V.end(); ++iter)
{
    ...
}
//新版本
for(auto iter = V.begin(); iter != V.begin(); ++iter)
{
    ...
}
//最简单版本 基于auto关键字的和范围for循环
for(auto val : V)
{
    ...
}
```

特殊例子：

```c++
// auto 常用于无名类型，例如 lambda 表达式的类型
auto lambda = [](int x) { return x + 3; };
auto ret = lambda(10); // ret的类型为int

auto lambda = [](auto a, auto b) { return a * b; };// c++14

```

**decltype**关键字用来取变量的类型，可以取到引用，右值、lambda这样的特殊类型。

```c++
int i = 33;
decltype(i) j = i * 2; // j的类型和i的类型相同，都为int

auto f = [](int a, int b) -> int
{
     return a * b;
};

decltype(f) g = f; // lambda 的类型是独有且无名的

```

### 3、初始化器列表 std::initializer_list

std::initializer_list是一个模板类，提供可以像初始化数组一样初始化对象，包括STL容器。

例子：

```c++
//老版写法
int iarray[] = {1,2,3,4,5}
std::vector<int>vec(iarray, iarray+sizeof(iarray)/sizeof(int));

//或者
int* begin = iarray;
int* end = iarray+sizeof(iarray)/sizeof(int);
for(int* iter = begin; iter != end; += iter)
{
    vec.push_back(*iter);
}

//新写法
std::vector<int>vec0 = {1,2,3,4,5};

std::unordered_map<int,std::string> map0 = 
{
    {0,"str0"},
    {1,"str1"};
    {2,"str2"};
    {3,"str3"};
};
```

一个initializer_list当出现在以下两种情况的被自动构造：

- 当初始化的时候使用大括号进行初始化，包括函数调用时和赋值。
- 当涉及到for(initializer : list), list被自动构造成initializer_list对象，即initializer_list对象只能使用大括号初始化，拷贝一个initializer_list对象并不会拷贝里面的元素，只是引用，而且元素都是const的。

```c++
//自己实现支持initializer_list初始化
template<typename T>
class initializer_example
{
public:
	typedef T value_type;
	initializer_example(std::initializer_list<value_type> _Ilist)
	{
		for (auto& obj: _Ilist)
		{
			obj_pool.push_back(obj);
		}

		//or
		//obj_pool = _Ilist;
	}

protected:
	std::vector<value_type> obj_pool;
};

initializer_example<int> ie = {1,2,3,4};
```

### 4、基于范围的循环

例子：

```c++
int iarr[] = { 0,1,2,3,4,5 };

// c++ 11 前
for (size_t i = 0;  i < sizeof(iarr)/sizeof(iarr[0]); i++)
{
    printf("%d", iarr[i]);
}

//基于范围的for循环
for (auto val : iarr)
{
    printf("%d", val);
}

//初始化器列表基于范围的for循环
for (auto val : {0,1,2,3,4,5})
{
    printf("%d", val);
}
```

最后这个例子大括号使initializer_list被自动构造了。

从c++17开始支持同时取索引和值，类似于python的循环取值。

例子：

```python
#python 2.7
vec = [1,2,3,4,5,6]
#k是索引 v为值
for k,v in enumerate(vec):
    print str(k) +','+str(v)

    
dic = {1:'one',2:'two'}
for k,v in dic.items():
    print str(k) +','+str(v)

```

C++：

```c++
std::unordered_map<int, std::string> map0 = {
    { 0, "value0"},
    { 1, "value1" },
    { 2, "value2" },
    { 3, "value3" },
};
for (auto [k,v] : map0){ } // since c++ 17


int *p = new int[6];
// 编译失败，原因是指针p没有begin函数，
// 而且指针是没有长度信息的。 因此基于范围的for循环不起作用
for (auto i : p)
{
    printf("%d", i);
}
```

### 5、override/final标识符

override：

- 在成员函数声明或定义中， override 确保该函数为虚并覆写来自基类的虚函数，若此非真则程序为病式（生成编译错误）。

- override 是在成员函数声明器后使用时拥有特殊含义的标识符，其他情况下它不是保留的关键词。

override的作用简单来说就是显示表明申明的函数是用来覆写基类的虚函数的，防止手误写错了参数造成没有覆写等等一些情况。

final：

- 在虚函数声明或定义中使用时， final 确保函数为虚且不可被派生类覆写。若这么做则程序生成编译时错误。在类定义中使用时，确保类不能被继承。

```c++
//函数定义中使用
class A
{
public:
    virtual void fun() { printf("A::fun\n"); }
    virtual void fun1() { printf("A::fun1\n"); }
};

class B : public A
{
public:
    virtual void fun()override { printf("B::fun\n"); }
    virtual void fun1()override final { printf("B::fun1\n"); }
};

class C : public B
{
public:
    virtual void fun()override { printf("C::fun\n"); }
    virtual void fun1()override { printf("C::fun1\n"); } // 编译错误
};


//类定义中使用
class A
{
public:
    virtual void fun() { printf("A::fun\n"); }
    virtual void fun1() { printf("A::fun1\n"); }
};

class B final : public A
{
public:
    virtual void fun()override { printf("B::fun\n"); }
    virtual void fun1()override { printf("B::fun1\n"); }
};

class C : public B // 编译错误，B不能用作基类
{
public:
    virtual void fun()override { printf("C::fun\n"); }
    virtual void fun1()override { printf("C::fun1\n"); }
};
```

###   6、default/delete特性