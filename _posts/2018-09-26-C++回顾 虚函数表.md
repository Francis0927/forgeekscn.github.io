---
layout:  post
title:		C++回顾  虚函数表等
subtitle:	C++常见问题（一）
date:     2018-09-26
author:   Francis-wu
header-img: img/post-bg-map.jpg
catalog: true
tags:
    - C++
---
>回顾复习一些常见的C++问题，以及一些没有仔细考虑过的地方。（任何问题欢迎邮件:[admin@fraciswu.top](admin@fraciswu.top)）

## 虚函数表

  	面向对象的三大特性：封装、继承和多态。派生类对基类函数进行实现或者覆盖，通过基类的指针在调用的时候能调用到派生类的的函数，这个过程就是依靠虚函数表实现的。  

  * 1、new一个对象的时候，只会给类中的成员变量分配空间，对象之间共享成员函数
  * 2、32位os 指针长度为4字节， 64位os 指针长度为8字节  

​	**sizeof是一个操作符，返回一个对象或类型所占的内存字节数**，基本类型如short、int、long、float、double等的大小和操作系统有关。
结构体的sizeof涉及到字节对齐，规则如下：  

* 1、结构体变量的首地址能够被其最宽基本类型成员的大小所整除
* 2、结构体的每个成员相对于结构体首地址的偏移量（offset）都是成员大小的整数倍，如有需要，编译器会在成员之间加上填充字节（internal adding）
* 3、结构体的总大小为结构体最宽基本类型成员大小的整数倍，如有需要，编译器会在最末一个成员后加上填充字节（trailing padding）。
* 4、空结构体（不含数据成员）的sizeof值为1

```c++
#include <iostream>

using namespace std;

class Base {
public:
    virtual void f() {cout<<"base::f"<<endl;}
    virtual void g() {cout<<"base::g"<<endl;}
    virtual void h() {cout<<"base::h"<<endl;}
};

class Derive : public Base{
public:
    void g() {cout<<"derive::g"<<endl;}
};

//可以稍后再看
int main () {
    cout<<"size of Base: "<<sizeof(Base)<<endl;

    typedef void(*Func)(void);
    Base b;
    Base *d = new Derive();

    long* pvptr = (long*)d;
    long* vptr = (long*)*pvptr;
    Func f = (Func)vptr[0];
    Func g = (Func)vptr[1];
    Func h = (Func)vptr[2];

    f();
    g();
    h();

    return 0;
}
```

  	win7 X64 VS2012中sizeof（Base）的值为4，说明编译器在类中自动添加了一个8字节的成员变量， 这个变量就是_vptr, 指向虚函数表的指针。

​	上面例子中取虚函数表中函数地址方式的原理如下图：

![](https://pichost1-1253970255.cos.ap-shanghai.myqcloud.com/pic001.png)

​	包含虚函数的类才会有虚函数表，同属于一个类的对象共享虚函数表，但是有各自的_vptr，虚函数表的实质是一个指针数组，里面存的是虚函数指针。

​	Base中的虚表结构：

![](https://pichost1-1253970255.cos.ap-shanghai.myqcloud.com/pic2.png)

​	Derive中的虚表结构：

![](https://pichost1-1253970255.cos.ap-shanghai.myqcloud.com/pic3.png)

## 析构函数

1、**类的设计目的如果不是作为base class使用，或不是为了具备多态性，析构函数就不该声明为虚函数**，原因如下：因为有虚函数的类就会有虚函数表存在，故对象体积会变大，同样因为虚表指针的存在，使得C++中类的对象不在和其他语言（如C）内的相同声明有着一样的结构,，因此也就不再可能把它传递至或接受其它语言所写的函数，故不在有移植性（除非你名确补偿vptr）。 
​	**带多态性质的base class或类中带有任何virtual函数，就一定要拥有一个virtual析构函数**，原因如下：假设derived class对象经由base class指针被删除，而该base class带着一个non-virtual析构函数，实际执行时通常会发生对象的derived成分没有被销毁。 

2、**不能在析构函数内调用虚函数**，原因如下：一旦derived class析构函数开始执行，对象的derived class成员就会呈现未定义值，所以C++ 就会视它仿佛不存在，进入base class析构后，对象就成为一个base class对象，而virtual函数和 dynamic_casts也这么认为，这也就失去了它动态调用的意义了。

## dynamic_cast

​	只能在有虚函数的情况下使用，依靠RTTI，要实现dynamic_cast，编译器会在每个含有虚函数的类的虚函数表的前四个字节存放一个指向_RTTICompleteObjectLocator结构的指针，当然还要额外空间存放RTTICompleteObjectLocator及其相关结构的数据。

## 内存管理
在C++中，内存分成5个区，他们分别是堆、栈、自由存储区、全局/静态存储区和常量存储区。
​	栈，在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。存放局部变量，函数参数，当前状态，函数调用信息等，向地址减小的方向增长，非常非常重要，可读可写可执行。

​	堆，就是那些由new分配的内存块，向地址增大的方向增长，可读可写可执行，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个delete。如果程序员没有释放掉，就会泄露。

​	自由存储区，就是那些由malloc等分配的内存块，他和堆是十分相似的，不过它是用free来结束自己的生命的。

​	全局/静态存储区，全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，他们共同占用同一块内存区。

​	常量存储区，这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改。

## 函数调用堆栈的过程

1、函数的运行都是在栈上开辟内存。

2、栈是通过esp（栈顶指针）、ebp（栈底指针）两个指针来标识的。

3、对于栈上的访问都是通过栈底指针的偏移来访问的。

4、在call一个函数时，有两件事情要做：先将调用函数的下一行指令的地址压入栈中；再进行跳转。

5、在函数调用时检查函数是否申明、函数名是否相同、函数的参数列表是否匹配、函数的返回值多大。

①如果  【函数的返回值<=4个字节】，则返回值通过寄存器eax带回。

②如果  【4<函数的返回值<=8个字节】，则返回值通过两个寄存器eax和edx带回。

③如果  【函数的返回值>8个字节】，则返回值通过产生的临时量带回。

6、函数结束ret指令干了两件事：先出栈；再将出栈的值放到CPU的PC寄存器中。因为PC寄存器中永远放的是下一次执行指令的地址，所以就顺理成章的在函数调用完之后依旧接着原来的代码继续执行。