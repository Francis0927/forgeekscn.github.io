---
layout:  post
title:		C++回顾  虚函数表等
subtitle:	C++常见问题（一）
date:     2018-09-26
author:   Francis-wu
header-img: img/post-bg-map.jpg
catalog: true
tags:
    - C++
---
>回顾复习一些常见的C++问题，以及一些没有仔细考虑过的地方。（任何问题欢迎邮件:[admin@fraciswu.top](admin@fraciswu.top)）

## 虚函数表

  	面向对象的三大特性：封装、继承和多态。派生类对基类函数进行实现或者覆盖，通过基类的指针在调用的时候能调用到派生类的的函数，这个过程就是依靠虚函数表实现的。  

  * 1、new一个对象的时候，只会给类中的成员变量分配空间，对象之间共享成员函数
  * 2、32位os 指针长度为4字节， 64位os 指针长度为8字节  

​	**sizeof是一个操作符，返回一个对象或类型所占的内存字节数**，基本类型如short、int、long、float、double等的大小和操作系统有关。
结构体的sizeof涉及到字节对齐，规则如下：  

* 1、结构体变量的首地址能够被其最宽基本类型成员的大小所整除
* 2、结构体的每个成员相对于结构体首地址的偏移量（offset）都是成员大小的整数倍，如有需要，编译器会在成员之间加上填充字节（internal adding）
* 3、结构体的总大小为结构体最宽基本类型成员大小的整数倍，如有需要，编译器会在最末一个成员后加上填充字节（trailing padding）。
* 4、空结构体（不含数据成员）的sizeof值为1

```c++
#include <iostream>

using namespace std;

class Base {
public:
    virtual void f() {cout<<"base::f"<<endl;}
    virtual void g() {cout<<"base::g"<<endl;}
    virtual void h() {cout<<"base::h"<<endl;}
};

class Derive : public Base{
public:
    void g() {cout<<"derive::g"<<endl;}
};

//可以稍后再看
int main () {
    cout<<"size of Base: "<<sizeof(Base)<<endl;

    typedef void(*Func)(void);
    Base b;
    Base *d = new Derive();

    long* pvptr = (long*)d;
    long* vptr = (long*)*pvptr;
    Func f = (Func)vptr[0];
    Func g = (Func)vptr[1];
    Func h = (Func)vptr[2];

    f();
    g();
    h();

    return 0;
}
```

  	win7 X64 VS2012中sizeof（Base）的值为4，说明编译器在类中自动添加了一个8字节的成员变量， 这个变量就是_vptr, 指向虚函数表的指针。

​	上面例子中取虚函数表中函数地址方式的原理如下图：

![](https://pichost1-1253970255.cos.ap-shanghai.myqcloud.com/pic001.png)

​	包含虚函数的类才会有虚函数表，同属于一个类的对象共享虚函数表，但是有各自的_vptr，虚函数表的实质是一个指针数组，里面存的是虚函数指针。

​	Base中的虚表结构：

![](https://pichost1-1253970255.cos.ap-shanghai.myqcloud.com/pic2.png)

​	Derive中的虚表结构：

![](https://pichost1-1253970255.cos.ap-shanghai.myqcloud.com/pic3.png)

## 内存管理

C++内存分为5个区域（堆栈全常代 ）：

1. 堆 heap ：
    堆向高地址方向增长。由new分配的内存块，其释放编译器不去管，由我们程序自己控制（一个new对应一个delete）。如果程序员没有释放掉，在程序结束时OS会自动回收。涉及的问题：“缓冲区溢出”、“内存泄露”

2. 栈 stack ：
    栈向低地址方向增长是。那些编译器在需要时分配，在不需要时自动清除的存储区。存放局部变量、函数参数。
    存放在栈中的数据只在当前函数及下一层函数中有效，一旦函数返回了，这些数据也就自动释放了。

3. 全局/静态存储区 （.bss段和.data段） ：
    全局和静态变量被分配到同一块内存中。在C语言中，未初始化的放在.bss段中，初始化的放在.data段中；在C++里则不区分了。

4. 常量存储区 （.rodata段） ：
    存放常量，不允许修改（通过非正当手段也可以修改）

5. 代码区 （.text段） ：
    存放代码（如函数），不允许修改（类似常量存储区），但可以执行（不同于常量存储区）

   部分是编译后程序的主体，也就是程序的机器指令。

根据c/c++对象生命周期不同，c/c++的内存模型有三种不同的内存区域，即

1. 自由存储区，动态区、静态区
2. **栈**：局部非静态变量的存储区域，即平常所说的栈
3. **堆**： 用operator new ，malloc分配的内存
4. 静态区：全局变量 静态变量 字符串常量存在位置

而代码虽然占内存，但不属于c/c++内存模型的一部分

## 析构函数

1、**类的设计目的如果不是作为base class使用，或不是为了具备多态性，析构函数就不该声明为虚函数**，原因如下：因为有虚函数的类就会有虚函数表存在，故对象体积会变大，同样因为虚表指针的存在，使得C++中类的对象不在和其他语言（如C）内的相同声明有着一样的结构,，因此也就不再可能把它传递至或接受其它语言所写的函数，故不在有移植性（除非你名确补偿vptr）。 
​	**带多态性质的base class或类中带有任何virtual函数，就一定要拥有一个virtual析构函数**，原因如下：假设derived class对象经由base class指针被删除，而该base class带着一个non-virtual析构函数，实际执行时通常会发生对象的derived成分没有被销毁。 

2、**不能在析构函数内调用虚函数**，原因如下：一旦derived class析构函数开始执行，对象的derived class成员就会呈现未定义值，所以C++ 就会视它仿佛不存在，进入base class析构后，对象就成为一个base class对象，而virtual函数和 dynamic_casts也这么认为，这也就失去了它动态调用的意义了。

## 各类_cast

### a、dynamic_cast	

​	只能在有虚函数的情况下使用，依靠RTTI，要实现dynamic_cast，编译器会在每个含有虚函数的类的虚函数表的前四个字节存放一个指向_RTTICompleteObjectLocator结构的指针，当然还要额外空间存放RTTICompleteObjectLocator及其相关结构的数据。

### b、static_cast

​	 static_cast可以转换相关联的类，可以从子类转换成父类。也能从父类转向子类，但是如果转换的父类指针（或者父类引用）所指向的对象是完整的，那么是没有问题；但是如果所指向的对象并不完整，那么会出现runtime错误。

 static_cast相对于dynamic_cast而言，除了能转换指针和引用，还能应用于任何能够隐式转换的情况。比如下面的情况：

```c++
     void test_static_cast()  
    {  
        float f =1.012;  
        int i = static_cast<int>(f);  
    }  
```

### c、reinterpret_cast

​	 该操作不会去进行动态类型或者静态类型的检测，它仅仅将值强行赋值过去。从某种意义上对编译器进行了一种欺骗，同时也带来了一定的不安全性。所以在使用这个cast的时候，要慎重。下面是这个操作的适用情况：

 （1）   Int和指针之间的相互转换；

 （2）   无关联类指针之间的转换；

 （3）   函数指针之间的转换

### d、const_cast

​	用来去除const和volatile。**去除const之后是可以对原对象修改的**。

## 函数调用堆栈的过程

1、函数的运行都是在栈上开辟内存。

2、栈是通过esp（栈顶指针）、ebp（栈底指针）两个指针来标识的。

3、对于栈上的访问都是通过栈底指针的偏移来访问的。

4、在call一个函数时，有两件事情要做：先将调用函数的下一行指令的地址压入栈中；再进行跳转。

5、在函数调用时检查函数是否申明、函数名是否相同、函数的参数列表是否匹配、函数的返回值多大。

①如果  【函数的返回值<=4个字节】，则返回值通过寄存器eax带回。

②如果  【4<函数的返回值<=8个字节】，则返回值通过两个寄存器eax和edx带回。

③如果  【函数的返回值>8个字节】，则返回值通过产生的临时量带回。

6、函数结束ret指令干了两件事：先出栈；再将出栈的值放到CPU的PC寄存器中。因为PC寄存器中永远放的是下一次执行指令的地址，所以就顺理成章的在函数调用完之后依旧接着原来的代码继续执行。