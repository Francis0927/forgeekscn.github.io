---
layout:  post
title:		游戏开发常见问题思考
subtitle:	C++常见问题（二）
date:     2018-09-26
author:   Francis-wu
header-img: img/post-bg-map.jpg
catalog: true
tags:
    - C++
---
>回顾复习一些常见的C++问题，以及一些没有仔细考虑过的地方。（任何问题欢迎邮件:[admin@fraciswu.top](admin@fraciswu.top)）

### 1、不同的继承方式

​	一般在开发过程中都用的public继承，突然问这个问题感觉有点不确定。其实比较简单，public < protect < private，具体效果如下图：

![https://pichost1-1253970255.cos.ap-shanghai.myqcloud.com/page2_01.png]()

### 2、常见的GC方式

​	一般的垃圾回收方式有三种：

#### a、标记清除方式

​	标记清除（Mark and Sweep）是最早开发出来的GC算法（1960年）。它的原理非常简单： 
**首先从根开始将可能被引用的对象用递归的方式进行标记，然后将没有标记到的对象作为垃圾进行回收。**

​	初始状态：

​	![https://pichost1-1253970255.cos.ap-shanghai.myqcloud.com/page2_02.png]()

​	标记阶段：

​	![https://pichost1-1253970255.cos.ap-shanghai.myqcloud.com/page2_03.png]()

​	![https://pichost1-1253970255.cos.ap-shanghai.myqcloud.com/page2_04.png]()

​	清除阶段：

​	![https://pichost1-1253970255.cos.ap-shanghai.myqcloud.com/page2_05.png]()

​	

​	上述图片显示了标记清除算法的大致原理。 
 “**初始状态**“图中显示了随着程序的运行而分配出一些对象的状态，一个对象可以对其他的对象进行引用。

“**标记阶段**“图中显示了GC开始执行，从根开始可以被引用的对象上进行“标记“。大多数情况下，这种标记是通过对象内部的标志（Flag）来实现的。于是，被标记的对象我们将它涂黑。

​	紧接着**被标记的对象所能引用的对象**也会被打上标记。重复这一步骤就可以从根开始可能被间接引用到的对象全部打上标记。到此为止的操作即被称为——**标记阶段**（Mark phase）。标记阶段完成时，**被标记的对象就是“存活“对象，反之为“死亡“对象**。

​	标记清除算法的处理时间，是和存活对象数与对象总数的总和相关的。作为标记清除的变形，还有一种叫做**标记压缩**（Mark and Compat）的算法，它不是将被标记的对象清除，而是将他们不断压缩。

#### b、复制收集方式

​	标记清除算法有一个缺点，就是在分配了大量对象，并且其中只有一小部分存活的情况下，所消耗的时间会大大超过必要的值，这是应为在清除阶段还需要对大量死亡对象进行扫描。

**	复制收集**（Copy and Collection）则试图克服这一缺点。在这种算法中，会**将从根开始被引用的对象复制到另外的空间中，然后，再将复制的对象所能够引用的对象用递归的方式不断复制下去**。

​	初始状态（1）——旧空间：

​	![https://pichost1-1253970255.cos.ap-shanghai.myqcloud.com/page2_06.png]()

​	新空间的开辟（2）——新空间：

​	![https://pichost1-1253970255.cos.ap-shanghai.myqcloud.com/page2_07.png]()

​	复制对象（3）：

​	![https://pichost1-1253970255.cos.ap-shanghai.myqcloud.com/page2_08.png]()

​	如上图： 
 （1）部分是GC开始前的内存状态，者也同时代表着对象在内存中所占用的“旧空间“。 
 图（2）在旧空间以外开辟“新空间“并将可能从根被引用的对象复制到新空间中。 
 图（3）从已经复制的对象开始再将可以被引用的对象逐个复制到新空间当中……随着复制的进行，直到复制完成——最终“死亡“对象就留在了“旧空间“当中，接着将旧空间废弃掉，这样就可以将“死亡“对象所占用的空间一口气释放出来，而没有必要再次扫描“死亡“对象的必要。而等到下次GC操作是，这次所创建的“新空间“就成为了将来的“旧空间“了。

​	**复制收集方式**的过程相当于只存在于**标记清除方式**中的**标记阶段**。**由于清除阶段中需要对所有对象进行扫描，这样如果在存在大量对象，且其中大量对象已经为“死亡“对象的情况下必然会造成不必要的资源和性能上的开销。** 
​	 而在复制收集方式中就不存在这样的开销。**但是和标记相比，将对象复制一份的开销相对要大，因此在“存活“对象相对比例较高的情况下，反而不利。**

​	复制收集方式的另一个优点是：它具有局部性（Locality）。在复制收集过程中，会按照对象被引用的顺序将对象复制到新空间中。于是，关系较近的对象被放置在距离较近的内存空间中的可能性会提高，这样被称为局部性。局部性高的情况下，内存缓存会更容易有效运作，程序的运行也能够得到提高。

#### c、	**引用计数方式**

​	它的原理是：**在每个对象中保存该对象的引用计数，当引用发生增减时对计数进行更新。** 
​	引用计数的增减，一般发生在变量复制，对象内容更新，函数结束（局部变量不在被引用），等时间点。当一个对象的引用计数为0时，则说明它将来不会再被引用，因此可以释放相应的内存空间	

​	**优点：**

- 相比**标记清除**和**复制收集**方式实现更容易。

- 当对象不再被引用的瞬间就会被释放。

- 其他GC机制中，要预测一个对象何时会被释放是很困难的，而在引用计数方式中则是立即被释放。

- 由于释放操作是针对个别执行的，因此和其他算法相比，由GC而产生的中断时间就比较短。

  **缺点：**

- 无法释放循环引用的对象。如上图A，B，C三个对象没有被其他对象引用，而是互相之间循环引用，因此他们的计数永远不会为0，结果这些对象就永远不会被释放。

- 必须在引用发生增减时对引用计数做出正确的增减，而如果漏掉或者更改了引用计数就会引发很难找到的内存错误。

- 引用计数不适合并行处理。如果多个线程同时对引用计数进行增减的话，引用计数的值就可能会产生不一致的问题（结果就会导致内存错误），为了避免这样的事情发生，对引用计数的操作必须采用独占的方式来进行。如果引用计数操作频繁发生，每次使用都要使用加锁等并发操作其开销也不可小觑。

#### d、其他方式：python中的分代

​	分代回收的整体思想是：将系统中的所有内存块根据其存活时间划分为不同的集合，每个集合就成为一个“代”，垃圾收集频率随着“代”的存活时间的增大而减小，存活时间通常利用经过几次垃圾回收来度量。

Python默认定义了三代对象集合，索引数越大，对象存活时间越长。

​	举例： 当某些内存块M经过了3次垃圾收集的清洗之后还存活时，我们就将内存块M划到一个集合A中去，而新分配的内存都划分到集合B中去。当垃圾收集开始工作时，大多数情况都只对集合B进行垃圾回收，而对集合A进行垃圾回收要隔相当长一段时间后才进行，这就使得垃圾收集机制需要处理的内存少了，效率自然就提高了。在这个过程中，集合B中的某些内存块由于存活时间长而会被转移到集合A中，当然，集合A中实际上也存在一些垃圾，这些垃圾的回收会因为这种分代的机制而被延迟。







​	





